状态的表示很容易想到。。由于只能单向前进（不管是从西向东还是从东向西）。。所以只要走过的点是不可能再在后面的规划中遇到的。。也就是说。。如果将题目考虑成同时有两个从西往东走。。那么每一个坐标点必然会立即加入两条路线中的一条。。于是。。我们可以用f[i][j]表示当前两条路线的最后一个点分别是i和j。。f[i][j]隐含的一个意思是：对于所有k<min(i,j)都已被决策。。不妨规定i>j因为不难发现f的对称性，即f[i][j]=f[j][i]。。接下来的事情就是分析f[i][j]能够由哪些状态转移得到。。

由于规定i>j。。故而为了维护这个性质。。新加入的点不可能归并入j。。所以我们只需要讨论新加入的点归并入i的情况。。这个逻辑最难理解的地方。。也是这个题目的关键。。因为f[i][j]=f[j][i]。。所以如果新节点介入j实际上等价于加入i。。而不是说我们只讨论加入i的情况。。

如此一来。。题目实际上是在让我们寻找尾端点靠后那条路的上一个端点。。也就是i的前继节点。。很明显。。i的前继不可能小于i-2。。原因就是我们始终维护i>j。。所以如果有i'<i-2那么j'<i'<i-2成立。。也就是说。。i-1这个节点将不会被访问。。显然与题意不符。。这么一来。。i的前继只能是i-1！下面我们考虑j。。由于i>j>=i-1。。j=i-1是可能成立的。。但是这样一来(i-1, i-1)违背了我们的规定。。故而我们需要对j=i-1的情况作特殊处理。。

总结一下。。到现在为止我们发现i的前继只可能是i-1,并且当j=i-1时我们需要特殊处理状态转移。。

接下来的事情就简单了。。当j!=i-1时，f[i][j]=f[i-1][j]+d[i-1][i]。。当j=i-1时，f[i][j]=f[i][i-1]=min(f[j][k]+d[k][i])=min(f[i-1][k]+d[k][i])。。

如果这上面的一切还是让你感到困扰。。或许你可以这样来理解。。始终把经过最后一个点的路当成第一条路做规划。。这样应该会清楚一点。。 